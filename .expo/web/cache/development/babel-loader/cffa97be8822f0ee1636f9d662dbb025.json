{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._TESTING_ONLY_reset_container_count = _TESTING_ONLY_reset_container_count;\nexports.default = createNavigationContainer;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _core = require(\"@react-navigation/core\");\n\nvar _invariant = _interopRequireDefault(require(\"./utils/invariant\"));\n\nvar _docsUrl = _interopRequireDefault(require(\"./utils/docsUrl\"));\n\nvar _excluded = [\"navigation\", \"screenProps\", \"persistNavigationState\", \"loadNavigationState\", \"theme\"];\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar urlToPathAndParams = _core.pathUtils.urlToPathAndParams;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn('You passed persistenceKey prop to a navigator. ' + 'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' + 'please see the navigation state persistence docs for more information. ' + 'Passing the persistenceKey prop is a no-op.');\n  }\n\n  if (isStateful(props)) {\n    return;\n  }\n\n  var navigation = props.navigation,\n      screenProps = props.screenProps,\n      persistNavigationState = props.persistNavigationState,\n      loadNavigationState = props.loadNavigationState,\n      theme = props.theme,\n      containerProps = (0, _objectWithoutProperties2.default)(props, _excluded);\n  var keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + \"unclear if it should own its own state. Remove props: \\\"\".concat(keys.join(', '), \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n\n  (0, _invariant.default)(persistNavigationState === undefined && loadNavigationState === undefined || typeof persistNavigationState === 'function' && typeof loadNavigationState === 'function', 'both persistNavigationState and loadNavigationState must either be undefined, or be functions');\n}\n\nvar _statefulContainerCount = 0;\n\nfunction _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\n\nvar _reactNavigationIsHydratingState = false;\n\nfunction createNavigationContainer(Component) {\n  var NavigationContainer = function (_React$Component) {\n    (0, _inherits2.default)(NavigationContainer, _React$Component);\n\n    var _super = _createSuper(NavigationContainer);\n\n    function NavigationContainer(props) {\n      var _this;\n\n      (0, _classCallCheck2.default)(this, NavigationContainer);\n      _this = _super.call(this, props);\n\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"subs\", null);\n\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"_actionEventSubscribers\", new Set());\n\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"_handleOpenURL\", function (_ref) {\n        var url = _ref.url;\n        var _this$props = _this.props,\n            enableURLHandling = _this$props.enableURLHandling,\n            uriPrefix = _this$props.uriPrefix;\n\n        if (enableURLHandling === false) {\n          return;\n        }\n\n        var parsedUrl = urlToPathAndParams(url, uriPrefix);\n\n        if (parsedUrl) {\n          var path = parsedUrl.path,\n              params = parsedUrl.params;\n          var action = Component.router.getActionForPathAndParams(path, params);\n\n          if (action) {\n            _this.dispatch(action);\n          }\n        }\n      });\n\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"_persistNavigationState\", function () {\n        var _ref2 = (0, _asyncToGenerator2.default)(function* (nav) {\n          var persistNavigationState = _this.props.persistNavigationState;\n\n          if (persistNavigationState) {\n            try {\n              yield persistNavigationState(nav);\n            } catch (err) {\n              console.warn('Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.');\n            }\n          }\n        });\n\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"dispatch\", function (action) {\n        if (_this.props.navigation) {\n          return _this.props.navigation.dispatch(action);\n        }\n\n        _this._navState = _this._navState || _this.state.nav;\n        var lastNavState = _this._navState;\n        (0, _invariant.default)(lastNavState, 'should be set in constructor if stateful');\n        var reducedState = Component.router.getStateForAction(action, lastNavState);\n        var navState = reducedState === null ? lastNavState : reducedState;\n\n        var dispatchActionEvents = function dispatchActionEvents() {\n          _this._actionEventSubscribers.forEach(function (subscriber) {\n            return subscriber({\n              type: 'action',\n              action: action,\n              state: navState,\n              lastState: lastNavState\n            });\n          });\n        };\n\n        if (reducedState === null) {\n          dispatchActionEvents();\n          return true;\n        }\n\n        if (navState !== lastNavState) {\n          _this._navState = navState;\n\n          _this.setState({\n            nav: navState\n          }, function () {\n            _this._onNavigationStateChange(lastNavState, navState, action);\n\n            dispatchActionEvents();\n\n            _this._persistNavigationState(navState);\n          });\n\n          return true;\n        }\n\n        dispatchActionEvents();\n        return false;\n      });\n\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"_getScreenProps\", function () {\n        return _this.props.screenProps;\n      });\n\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"_getTheme\", function () {\n        if (_this.props.theme === 'light' || _this.props.theme === 'dark') {\n          return _this.props.theme;\n        } else if (_this.props.theme === 'no-preference') {\n          return 'light';\n        } else {\n          console.warn(\"Invalid theme provided: \".concat(_this.props.theme, \". Only 'light' and 'dark' are supported. Falling back to 'light'\"));\n          return 'light';\n        }\n      });\n\n      validateProps(props);\n      _this._initialAction = _core.NavigationActions.init();\n\n      if (_this._isStateful() && _reactNative.BackHandler && typeof _reactNative.BackHandler.addEventListener === 'function') {\n        _this.subs = _reactNative.BackHandler.addEventListener('hardwareBackPress', function () {\n          if (!_this._isMounted) {\n            _this.subs && _this.subs.remove();\n          } else {\n            return _this.dispatch(_core.NavigationActions.back());\n          }\n        });\n      }\n\n      _this.state = {\n        nav: _this._isStateful() && !props.loadNavigationState ? Component.router.getStateForAction(_this._initialAction) : null\n      };\n      return _this;\n    }\n\n    (0, _createClass2.default)(NavigationContainer, [{\n      key: \"_renderLoading\",\n      value: function _renderLoading() {\n        return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n      }\n    }, {\n      key: \"_isStateful\",\n      value: function _isStateful() {\n        return isStateful(this.props);\n      }\n    }, {\n      key: \"_onNavigationStateChange\",\n      value: function _onNavigationStateChange(prevNav, nav, action) {\n        if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n          if (console.group) {\n            console.group('Navigation Dispatch: ');\n            console.log('Action: ', action);\n            console.log('New State: ', nav);\n            console.log('Last State: ', prevNav);\n            console.groupEnd();\n          } else {\n            console.log('Navigation Dispatch: ', {\n              action: action,\n              newState: nav,\n              lastState: prevNav\n            });\n          }\n\n          return;\n        }\n\n        if (typeof this.props.onNavigationStateChange === 'function') {\n          this.props.onNavigationStateChange(prevNav, nav, action);\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate() {\n        if (this._navState === this.state.nav) {\n          this._navState = null;\n        }\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function () {\n        var _componentDidMount = (0, _asyncToGenerator2.default)(function* () {\n          var _this2 = this;\n\n          this._isMounted = true;\n\n          if (!this._isStateful()) {\n            return;\n          }\n\n          if (process.env.NODE_ENV !== 'production' && !this.props.detached) {\n            if (_statefulContainerCount > 0) {\n              if (_reactNative.Platform.OS === 'ios') {\n                console.warn(\"You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: \".concat((0, _docsUrl.default)('common-mistakes.html#explicitly-rendering-more-than-one-navigator')));\n              }\n            }\n          }\n\n          _statefulContainerCount++;\n          this._linkingSub = _reactNative.Linking.addEventListener('url', this._handleOpenURL);\n          var parsedUrl = null;\n          var userProvidedStartupState = null;\n\n          if (this.props.enableURLHandling !== false) {\n            var _yield$this$getStartu = yield this.getStartupParams();\n\n            parsedUrl = _yield$this$getStartu.parsedUrl;\n            userProvidedStartupState = _yield$this$getStartu.userProvidedStartupState;\n          }\n\n          var action = this._initialAction;\n          var startupState = this.state.nav;\n\n          if (!startupState && !userProvidedStartupState) {\n            !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n            startupState = Component.router.getStateForAction(action);\n          }\n\n          if (userProvidedStartupState) {\n            startupState = userProvidedStartupState;\n            _reactNavigationIsHydratingState = true;\n          }\n\n          if (parsedUrl) {\n            var _parsedUrl = parsedUrl,\n                path = _parsedUrl.path,\n                params = _parsedUrl.params;\n            var urlAction = Component.router.getActionForPathAndParams(path, params);\n\n            if (urlAction) {\n              !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\n              action = urlAction;\n              startupState = Component.router.getStateForAction(urlAction, startupState);\n            }\n          }\n\n          var dispatchActions = function dispatchActions() {\n            return _this2._actionEventSubscribers.forEach(function (subscriber) {\n              return subscriber({\n                type: 'action',\n                action: action,\n                state: _this2.state.nav,\n                lastState: null\n              });\n            });\n          };\n\n          if (startupState === this.state.nav) {\n            dispatchActions();\n            return;\n          }\n\n          this.setState({\n            nav: startupState\n          }, function () {\n            _reactNavigationIsHydratingState = false;\n            dispatchActions();\n          });\n        });\n\n        function componentDidMount() {\n          return _componentDidMount.apply(this, arguments);\n        }\n\n        return componentDidMount;\n      }()\n    }, {\n      key: \"getStartupParams\",\n      value: function () {\n        var _getStartupParams = (0, _asyncToGenerator2.default)(function* () {\n          var _this$props2 = this.props,\n              uriPrefix = _this$props2.uriPrefix,\n              loadNavigationState = _this$props2.loadNavigationState;\n          var url, loadedNavState;\n\n          try {\n            var _yield$Promise$all = yield Promise.all([_reactNative.Linking.getInitialURL(), loadNavigationState && loadNavigationState()]);\n\n            var _yield$Promise$all2 = (0, _slicedToArray2.default)(_yield$Promise$all, 2);\n\n            url = _yield$Promise$all2[0];\n            loadedNavState = _yield$Promise$all2[1];\n          } catch (err) {}\n\n          return {\n            parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n            userProvidedStartupState: loadedNavState\n          };\n        });\n\n        function getStartupParams() {\n          return _getStartupParams.apply(this, arguments);\n        }\n\n        return getStartupParams;\n      }()\n    }, {\n      key: \"componentDidCatch\",\n      value: function componentDidCatch(e) {\n        if (_reactNavigationIsHydratingState) {\n          _reactNavigationIsHydratingState = false;\n          console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...');\n          this.dispatch(_core.NavigationActions.init());\n        } else {\n          throw e;\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        var _this$_linkingSub;\n\n        this._isMounted = false;\n\n        if ((_this$_linkingSub = this._linkingSub) === null || _this$_linkingSub === void 0 ? void 0 : _this$_linkingSub.remove) {\n          var _this$_linkingSub2;\n\n          (_this$_linkingSub2 = this._linkingSub) === null || _this$_linkingSub2 === void 0 ? void 0 : _this$_linkingSub2.remove();\n        } else {\n          _reactNative.Linking.removeEventListener('url', this._handleOpenURL);\n        }\n\n        this.subs && this.subs.remove();\n\n        if (this._isStateful()) {\n          _statefulContainerCount--;\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this3 = this;\n\n        var navigation = this.props.navigation;\n\n        if (this._isStateful()) {\n          var navState = this.state.nav;\n\n          if (!navState) {\n            return this._renderLoading();\n          }\n\n          if (!this._navigation || this._navigation.state !== navState) {\n            this._navigation = (0, _core.getNavigation)(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, function () {\n              return _this3._navigation;\n            });\n          }\n\n          navigation = this._navigation;\n        }\n\n        (0, _invariant.default)(navigation, 'failed to get navigation');\n        return React.createElement(_core.ThemeProvider, {\n          value: this._getTheme()\n        }, React.createElement(_core.NavigationProvider, {\n          value: navigation\n        }, React.createElement(Component, _extends({}, this.props, {\n          navigation: navigation\n        }))));\n      }\n    }], [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(nextProps) {\n        validateProps(nextProps);\n        return null;\n      }\n    }]);\n    return NavigationContainer;\n  }(React.Component);\n\n  _defineProperty(NavigationContainer, \"router\", Component.router);\n\n  _defineProperty(NavigationContainer, \"navigationOptions\", null);\n\n  _defineProperty(NavigationContainer, \"defaultProps\", {\n    theme: 'light'\n  });\n\n  return NavigationContainer;\n}","map":{"version":3,"sources":["createAppContainer.js"],"names":["urlToPathAndParams","props","console","isStateful","containerProps","keys","Object","invariant","persistNavigationState","loadNavigationState","_statefulContainerCount","_reactNavigationIsHydratingState","React","Component","theme","validateProps","constructor","NavigationActions","BackHandler","nav","_renderLoading","_isStateful","url","uriPrefix","enableURLHandling","parsedUrl","params","action","_onNavigationStateChange","process","newState","lastState","prevNav","componentDidUpdate","Platform","docsUrl","Linking","userProvidedStartupState","startupState","urlAction","dispatchActions","subscriber","type","state","Promise","loadedNavState","componentDidCatch","componentWillUnmount","lastNavState","reducedState","navState","dispatchActionEvents","render","navigation","getNavigation"],"mappings":"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","sourcesContent":["/* eslint-disable react/sort-comp */\n\nimport * as React from 'react';\nimport { Linking, Platform, BackHandler } from 'react-native';\nimport {\n  NavigationActions,\n  ThemeProvider,\n  pathUtils,\n  getNavigation,\n  NavigationProvider,\n} from '@react-navigation/core';\nimport invariant from './utils/invariant';\nimport docsUrl from './utils/docsUrl';\n\nconst { urlToPathAndParams } = pathUtils;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn(\n      'You passed persistenceKey prop to a navigator. ' +\n        'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' +\n        'please see the navigation state persistence docs for more information. ' +\n        'Passing the persistenceKey prop is a no-op.'\n    );\n  }\n  if (isStateful(props)) {\n    return;\n  }\n  /* eslint-disable no-unused-vars */\n  const {\n    navigation,\n    screenProps,\n    persistNavigationState,\n    loadNavigationState,\n    theme,\n    ...containerProps\n  } = props;\n  /* eslint-enable no-unused-vars */\n\n  const keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error(\n      'This navigator has both navigation and container props, so it is ' +\n        `unclear if it should own its own state. Remove props: \"${keys.join(\n          ', '\n        )}\" ` +\n        'if the navigator should get its state from the navigation prop. If the ' +\n        'navigator should maintain its own state, do not pass a navigation prop.'\n    );\n  }\n  invariant(\n    (persistNavigationState === undefined &&\n      loadNavigationState === undefined) ||\n      (typeof persistNavigationState === 'function' &&\n        typeof loadNavigationState === 'function'),\n    'both persistNavigationState and loadNavigationState must either be undefined, or be functions'\n  );\n}\n\n// Track the number of stateful container instances. Warn if >0 and not using the\n// detached prop to explicitly acknowledge the behavior. We should deprecated implicit\n// stateful navigation containers in a future release and require a provider style pattern\n// instead in order to eliminate confusion entirely.\nlet _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\n\n// We keep a global flag to catch errors during the state persistence hydrating scenario.\n// The innermost navigator who catches the error will dispatch a new init action.\nlet _reactNavigationIsHydratingState = false;\n// Unfortunate to use global state here, but it seems necessesary for the time\n// being. There seems to be some problems with cascading componentDidCatch\n// handlers. Ideally the inner non-stateful navigator catches the error and\n// re-throws it, to be caught by the top-level stateful navigator.\n\n/**\n * Create an HOC that injects the navigation and manages the navigation state\n * in case it's not passed from above.\n * This allows to use e.g. the StackNavigator and TabNavigator as root-level\n * components.\n */\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    subs = null;\n\n    static router = Component.router;\n    static navigationOptions = null;\n\n    static defaultProps = {\n      theme: 'light',\n    };\n\n    static getDerivedStateFromProps(nextProps) {\n      validateProps(nextProps);\n      return null;\n    }\n\n    _actionEventSubscribers = new Set();\n\n    constructor(props) {\n      super(props);\n\n      validateProps(props);\n\n      this._initialAction = NavigationActions.init();\n\n      if (\n        this._isStateful() &&\n        BackHandler &&\n        typeof BackHandler.addEventListener === 'function'\n      ) {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            // dispatch returns true if the action results in a state change,\n            // and false otherwise. This maps well to what BackHandler expects\n            // from a callback -- true if handled, false if not handled\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      this.state = {\n        nav:\n          this._isStateful() && !props.loadNavigationState\n            ? Component.router.getStateForAction(this._initialAction)\n            : null,\n      };\n    }\n\n    _renderLoading() {\n      return this.props.renderLoadingExperimental\n        ? this.props.renderLoadingExperimental()\n        : null;\n    }\n\n    _isStateful() {\n      return isStateful(this.props);\n    }\n\n    _handleOpenURL = ({ url }) => {\n      const { enableURLHandling, uriPrefix } = this.props;\n      if (enableURLHandling === false) {\n        return;\n      }\n      const parsedUrl = urlToPathAndParams(url, uriPrefix);\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const action = Component.router.getActionForPathAndParams(path, params);\n        if (action) {\n          this.dispatch(action);\n        }\n      }\n    };\n\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (\n        typeof this.props.onNavigationStateChange === 'undefined' &&\n        this._isStateful() &&\n        !!process.env.REACT_NAV_LOGGING\n      ) {\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav,\n          });\n        }\n        return;\n      }\n\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n\n    componentDidUpdate() {\n      // Clear cached _navState every tick\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n\n    async componentDidMount() {\n      this._isMounted = true;\n      if (!this._isStateful()) {\n        return;\n      }\n\n      if (process.env.NODE_ENV !== 'production' && !this.props.detached) {\n        if (_statefulContainerCount > 0) {\n          // Temporarily only show this on iOS due to this issue:\n          // https://github.com/react-navigation/react-navigation/issues/4196#issuecomment-390827829\n          if (Platform.OS === 'ios') {\n            console.warn(\n              `You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: ${docsUrl(\n                'common-mistakes.html#explicitly-rendering-more-than-one-navigator'\n              )}`\n            );\n          }\n        }\n      }\n      _statefulContainerCount++;\n      this._linkingSub = Linking.addEventListener('url', this._handleOpenURL);\n\n      // Pull out anything that can impact state\n      let parsedUrl = null;\n      let userProvidedStartupState = null;\n      if (this.props.enableURLHandling !== false) {\n        ({\n          parsedUrl,\n          userProvidedStartupState,\n        } = await this.getStartupParams());\n      }\n\n      // Initialize state. This must be done *after* any async code\n      // so we don't end up with a different value for this.state.nav\n      // due to changes while async function was resolving\n      let action = this._initialAction;\n      // eslint-disable-next-line react/no-access-state-in-setstate\n      let startupState = this.state.nav;\n      if (!startupState && !userProvidedStartupState) {\n        !!process.env.REACT_NAV_LOGGING &&\n          console.log('Init new Navigation State');\n        startupState = Component.router.getStateForAction(action);\n      }\n\n      // Pull user-provided persisted state\n      if (userProvidedStartupState) {\n        startupState = userProvidedStartupState;\n        _reactNavigationIsHydratingState = true;\n      }\n\n      // Pull state out of URL\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const urlAction = Component.router.getActionForPathAndParams(\n          path,\n          params\n        );\n        if (urlAction) {\n          !!process.env.REACT_NAV_LOGGING &&\n            console.log(\n              'Applying Navigation Action for Initial URL:',\n              parsedUrl\n            );\n          action = urlAction;\n          startupState = Component.router.getStateForAction(\n            urlAction,\n            startupState\n          );\n        }\n      }\n\n      const dispatchActions = () =>\n        this._actionEventSubscribers.forEach((subscriber) =>\n          subscriber({\n            type: 'action',\n            action,\n            state: this.state.nav,\n            lastState: null,\n          })\n        );\n\n      if (startupState === this.state.nav) {\n        dispatchActions();\n        return;\n      }\n\n      // eslint-disable-next-line react/no-did-mount-set-state\n      this.setState({ nav: startupState }, () => {\n        _reactNavigationIsHydratingState = false;\n        dispatchActions();\n      });\n    }\n\n    async getStartupParams() {\n      const { uriPrefix, loadNavigationState } = this.props;\n      let url, loadedNavState;\n      try {\n        [url, loadedNavState] = await Promise.all([\n          Linking.getInitialURL(),\n          loadNavigationState && loadNavigationState(),\n        ]);\n      } catch (err) {\n        // ignore\n      }\n      return {\n        parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n        userProvidedStartupState: loadedNavState,\n      };\n    }\n\n    componentDidCatch(e) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn(\n          'Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...'\n        );\n        this.dispatch(NavigationActions.init());\n      } else {\n        throw e;\n      }\n    }\n\n    _persistNavigationState = async (nav) => {\n      const { persistNavigationState } = this.props;\n      if (persistNavigationState) {\n        try {\n          await persistNavigationState(nav);\n        } catch (err) {\n          console.warn(\n            'Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.'\n          );\n        }\n      }\n    };\n\n    componentWillUnmount() {\n      this._isMounted = false;\n\n      // https://github.com/facebook/react-native/commit/6d1aca806cee86ad76de771ed3a1cc62982ebcd7\n      if (this._linkingSub?.remove) {\n        this._linkingSub?.remove();\n      } else {\n        Linking.removeEventListener('url', this._handleOpenURL);\n      }\n\n      this.subs && this.subs.remove();\n\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n\n    // Per-tick temporary storage for state.nav\n\n    dispatch = (action) => {\n      if (this.props.navigation) {\n        return this.props.navigation.dispatch(action);\n      }\n\n      // navState will have the most up-to-date value, because setState sometimes behaves asyncronously\n      this._navState = this._navState || this.state.nav;\n      const lastNavState = this._navState;\n      invariant(lastNavState, 'should be set in constructor if stateful');\n      const reducedState = Component.router.getStateForAction(\n        action,\n        lastNavState\n      );\n      const navState = reducedState === null ? lastNavState : reducedState;\n\n      const dispatchActionEvents = () => {\n        this._actionEventSubscribers.forEach((subscriber) =>\n          subscriber({\n            type: 'action',\n            action,\n            state: navState,\n            lastState: lastNavState,\n          })\n        );\n      };\n\n      if (reducedState === null) {\n        // The router will return null when action has been handled and the state hasn't changed.\n        // dispatch returns true when something has been handled.\n        dispatchActionEvents();\n        return true;\n      }\n\n      if (navState !== lastNavState) {\n        // Cache updates to state.nav during the tick to ensure that subsequent calls will not discard this change\n        this._navState = navState;\n        this.setState({ nav: navState }, () => {\n          this._onNavigationStateChange(lastNavState, navState, action);\n          dispatchActionEvents();\n          this._persistNavigationState(navState);\n        });\n        return true;\n      }\n\n      dispatchActionEvents();\n      return false;\n    };\n\n    _getScreenProps = () => this.props.screenProps;\n\n    _getTheme = () => {\n      if (this.props.theme === 'light' || this.props.theme === 'dark') {\n        return this.props.theme;\n      } else if (this.props.theme === 'no-preference') {\n        return 'light';\n      } else {\n        console.warn(\n          `Invalid theme provided: ${this.props.theme}. Only 'light' and 'dark' are supported. Falling back to 'light'`\n        );\n        return 'light';\n      }\n    };\n\n    render() {\n      let navigation = this.props.navigation;\n      if (this._isStateful()) {\n        const navState = this.state.nav;\n        if (!navState) {\n          return this._renderLoading();\n        }\n        if (!this._navigation || this._navigation.state !== navState) {\n          this._navigation = getNavigation(\n            Component.router,\n            navState,\n            this.dispatch,\n            this._actionEventSubscribers,\n            this._getScreenProps,\n            () => this._navigation\n          );\n        }\n        navigation = this._navigation;\n      }\n      invariant(navigation, 'failed to get navigation');\n\n      return (\n        <ThemeProvider value={this._getTheme()}>\n          <NavigationProvider value={navigation}>\n            <Component {...this.props} navigation={navigation} />\n          </NavigationProvider>\n        </ThemeProvider>\n      );\n    }\n  }\n\n  return NavigationContainer;\n}\n"]},"metadata":{},"sourceType":"script"}